<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_BasicFun" Id="{b1929ee2-bebd-4d66-9cbe-759cc2fb8f71}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BasicFun
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="forwardKinematic" Id="{023f24df-f29a-4025-8e80-838014e504aa}">
      <Declaration><![CDATA[// from active joint position to cartesian pose in arm origin
//METHOD PROTECTED forwardKinematic : BOOL
METHOD forwardKinematic : BOOL
VAR_IN_OUT CONSTANT
	i_DHJntPos :Vec6d;
	m_instrument : FB_Instrument;
END_VAR
VAR_IN_OUT
	r_cartPose :ST_Frame;
END_VAR
VAR
	d1, L, a, b :LREAL;
	q3 :LREAL;
	c1,c2,c4,c5,c6,c7 :LREAL;
	s1,s2,s4,s5,s6,s7 :LREAL;
	DHRot :Mat3d;	
	tmpRot1,tmpRot2 : Mat3d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[d1:=GVL_SlaveArmKinematic.g_d1;
L:=m_instrument.kinematicParameters.m_rodLength;
a:=m_instrument.kinematicParameters.m_headLength;
//b:=m_instrument.kinematicParameters.m_fingerLength;
b:=0;

q3:=i_DHJntPos[3];
c1:=COS(i_DHJntPos[1]);
c2:=COS(i_DHJntPos[2]);
c4:=COS(i_DHJntPos[4]);
c5:=COS(i_DHJntPos[5]);
c6:=COS(i_DHJntPos[6]);

s1:=SIN(i_DHJntPos[1]);
s2:=SIN(i_DHJntPos[2]);
s4:=SIN(i_DHJntPos[4]);
s5:=SIN(i_DHJntPos[5]);
s6:=SIN(i_DHJntPos[6]);


// cartesian pose frame
r_cartPose.m_pos[1]:=a*(c5*(s1*s4 + c1*c2*c4) - c1*s2*s5) + b*(c6*(c5*(s1*s4 + c1*c2*c4) - c1*s2*s5) - s6*(c4*s1 - c1*c2*s4)) + L*c1*s2 - q3*c1*s2;
r_cartPose.m_pos[2]:=a*(c2*s5 + c4*c5*s2) - d1 - L*c2 + q3*c2 + b*(c6*(c2*s5 + c4*c5*s2) + s2*s4*s6);
r_cartPose.m_pos[3]:=L*s1*s2 - a*(c5*(c1*s4 - c2*c4*s1) + s1*s2*s5) - b*(c6*(c5*(c1*s4 - c2*c4*s1) + s1*s2*s5) - s6*(c1*c4 + c2*s1*s4)) - q3*s1*s2;

DHRot[1,1]:= c6*(c5*(s1*s4 + c1*c2*c4) - c1*s2*s5) - s6*(c4*s1 - c1*c2*s4);
DHRot[2,1]:=c6*(c2*s5 + c4*c5*s2) + s2*s4*s6;
DHRot[3,1]:=s6*(c1*c4 + c2*s1*s4) - c6*(c5*(c1*s4 - c2*c4*s1) + s1*s2*s5);

DHRot[1,2]:=- s6*(c5*(s1*s4 + c1*c2*c4) - c1*s2*s5) - c6*(c4*s1 - c1*c2*s4);
DHRot[2,2]:=c6*s2*s4 - s6*(c2*s5 + c4*c5*s2);
DHRot[3,2]:=s6*(c5*(c1*s4 - c2*c4*s1) + s1*s2*s5) + c6*(c1*c4 + c2*s1*s4);

DHRot[1,3]:= s5*(s1*s4 + c1*c2*c4) + c1*c5*s2;
DHRot[2,3]:= c4*s2*s5 - c2*c5;
DHRot[3,3]:=c5*s1*s2 - s5*(c1*s4 - c2*c4*s1);

// convert to tcp rotation
matMultiply(DHRot, GVL_SlaveArmKinematic.g_tcpRotation, r_cartPOSE.m_rot);

//TODO: need verify
// rotate tcp coordinate 180 degree about z axis if instrument is a head-up 30deg endoscope
IF m_instrument.instruType = InstruType_Endoscope AND m_instrument.curScopeType = EndoScopeType_30 AND m_instrument.curScopePosture = EndoscopePosture_HeadUp THEN
	tmpRot2 := rotZ(pi);
	tmpRot1 := r_cartPOSE.m_rot;
	matMultiply(tmpRot1, tmpRot2, r_cartPOSE.m_rot);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="rpy2rot" Id="{e6e081a3-5adf-4d3c-acb8-2d8afb78f278}">
      <Declaration><![CDATA[METHOD rpy2rot : BOOL
VAR_INPUT
	i_rpy:Vec3d;
END_VAR

VAR_OUTPUT
	o_rot:Mat3d;
END_VAR

VAR
	rot_x,rot_y,rot_z:LREAL;
	alpha,beta,gama:LREAL;
	matrix_out:ARRAY[1..3,1..3] OF LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
alpha:=rot_z;
beta:=rot_y;
gama:=rot_x;

matrix_out[1,1]:=COS(alpha)*COS(beta);
matrix_out[2,1]:=SIN(alpha)*COS(beta);
matrix_out[3,1]:=-SIN(beta);

matrix_out[1,2]:=COS(alpha)*SIN(beta)*SIN(gama)-SIN(alpha)*COS(gama);
matrix_out[2,2]:=SIN(alpha)*SIN(beta)*SIN(gama)+COS(alpha)*COS(gama);
matrix_out[3,2]:=COS(beta)*SIN(gama);

matrix_out[1,3]:=COS(alpha)*SIN(beta)*COS(gama)+SIN(alpha)*SIN(gama);
matrix_out[2,3]:=SIN(alpha)*SIN(beta)*COS(gama)-COS(alpha)*SIN(gama);
matrix_out[3,3]:=COS(beta)*COS(gama);

o_rot:=matrix_out;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="xyzrpy2Frame" Id="{b0ab14e4-bacf-434c-b592-fae2dc9477e2}">
      <Declaration><![CDATA[METHOD xyzrpy2Frame : BOOL
VAR_INPUT
	i_posVec:Vec6d;
END_VAR

VAR_OUTPUT
	o_frame:ST_Frame;
END_VAR

VAR
	i:INT;
	rpyVec:Vec3d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i:=1 TO 3 BY 1 DO
	o_frame.m_pos[i]:=i_posVec[i];
	rpyVec[i]:=i_posVec[i+3];
END_FOR
rpy2rot(i_rpy:= rpyVec, o_rot=> o_frame.m_rot) ;

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_BasicFun">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicFun.forwardKinematic">
      <LineId Id="290" Count="47" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicFun.rpy2rot">
      <LineId Id="7" Count="0" />
      <LineId Id="21" Count="7" />
      <LineId Id="30" Count="2" />
      <LineId Id="34" Count="3" />
      <LineId Id="39" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicFun.xyzrpy2Frame">
      <LineId Id="7" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>