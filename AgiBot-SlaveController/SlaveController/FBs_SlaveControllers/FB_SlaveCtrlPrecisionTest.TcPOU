<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_SlaveCtrlPrecisionTest" Id="{1902434d-be0a-47a5-87d4-f277642374f0}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SlaveCtrlPrecisionTest EXTENDS FB_SlaveArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//arm id
	m_armId:INT;	
	
	//Precision calculation pre matrix
	m_frontPose:ST_Frame;
	
	//Precision calculation post matrix
	m_endPose:ST_Frame;
	
	//single arm pose
	m_slaveArmPose:ST_Frame;
	
	//control mode:  1---Joint space single point motion   2---Continuous joint space motion   3---Single point motion in operating space
	//4---Continuous motion in operating space   5---precision test   6---back to origin position
	m_controlMode:INT:=1;
	
	//test step
	m_testStep:INT;
	
	//DH joint position
	m_initDHPos,m_startDHPos,m_endDHPos :Vec6d;
	
	//startJntPos,endJntPos :Vec8d;
	m_initJntPos,m_startJntPos,m_endJntPos :Vec8d;
	
	//Trajectory planner
	m_Planner: FB_TrajMoveJ;
	
	//motion parameters
	m_maxjntVel,m_maxjntAcc,m_maxjntJerk:Vec8d;
	
	// joint velocity limit
	m_DHJntVel :ARRAY[1..6] OF LREAL :=[1, 1, 0.5, 1,1,1];
	m_maxDHJntVel :ARRAY[1..6] OF LREAL :=[1, 1, 0.5, 1,1,1];	
	m_velFactor:ARRAY[1..2] OF LREAL:=[0.1,1];//lowVel  highVel
	
	//time
	m_time:LREAL;
	
	//joint motion incresement
	m_DHjntInc:Vec6d;
	
	//moiton parameters
	m_jntMotionDir:Vec6i:=[0,0,0,0,0,0];
	m_jntVel:Vec6d:=[0.1,0.1,0.01,0.2,0.2,0.2];
	
	//motion start
	m_startMotion:BOOL;
	m_startMotionLast:BOOL;
	
	//target spatial position
	m_targetSpatialPos:ST_Frame;
	
	//spatial motion parameters
	m_spatialMotionDir:Vec6i;
	m_spatialVel:Vec6d;
	
	//spatial position incresement
	m_spatialPosInc:Vec6d;
	
	//initial spatial position
	m_initSpatialPos:ST_Frame;
	
	//target position variables
	m_posInc:Vec3d;
	m_axis:Vec3d;
	m_angle:LREAL;
	
	//accuracy test variables
	m_pointNum:INT;
	m_pointSum:INT;
	m_motionCycleNum:INT;
	m_targetPosArr:ARRAY[1..5] OF ST_Frame;
	
	//Has the inverse kinematics been successfully solved
	m_IKSucceed:BOOL;	
	
	//Numerical method for inverse solution of related variables
	//m_cmdCartPose:ST_Frame;
	m_slavePosErr :Vec3d;
	m_slaveRotErr :Mat3d;
	m_errAngle : LREAL;
	m_errAxisLocal, m_errAxis :Vec3d;
	m_masterSlavePoseError :Vec6d;
	
	// pose track control kp
	m_posTrackKp :REAL := 100;
	m_oriTrackKp :REAL := 100;
	
	// velocity for slave to track motion
	m_slaveCmdVel, m_slaveCmdWVel : Vec3d;
	invJaco :Mat6d;
	
	//spatial velocity limit
	m_linearVelLimit:LREAL:=0.1;
	m_angularVelLimit:LREAL:=5*g_deg2Rad;
	
	// simulated DH joint position
	m_simDHJntPos : Vec6d;
	
	// simulated slave twist of DH joint
	m_simDHJointVel :Vec6d;
	
	// command joint position filter
	m_cmdJntPosLpf:ARRAY[1..8] OF FB_LowPassFilter;
	
	// filter cut-off frequency for control
	m_macroCmdJntPosLpfCutoffFreq : LREAL :=5;
	m_microCmdJntPosLpfCutoffFreq : LREAL :=15;
	
	//position and posture error limit
	m_distErrLimit:LREAL:=0.001*0.1;
	m_poseErrLimit:LREAL:=0.01*g_deg2Rad;
	m_delayTimeLimit:LREAL:=1;
	m_errTime:LREAL;
	
	//original joint position
	m_originJntPos:Vec6d;
	
	//motion status
	m_motionFinished:BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="accuracyTest" Id="{3de375b6-4f4e-4ec7-8c4b-4769583261f7}">
      <Declaration><![CDATA[METHOD accuracyTest : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(*
CASE m_testStep OF
	0: //data initial		
		m_targetSpatialPos:=m_targetPosArr[m_pointNum];
		m_startDHPos:=i_slaveArm.curDHJntPos;
		m_IKSucceed:=i_slaveArm.inverseKinematic(i_targetSpatialPos:= m_targetSpatialPos, i_startDHJntPos:= m_startDHPos, o_outputDHJntPos=> m_endDHPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=30;
		END_IF
		
		m_startJntPos:=i_slaveArm.curJntPos;	
		i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=30;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start the motion
		m_time:=m_time+g_slaveArmCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;			
		END_IF
		
		
	20: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>5) THEN
				m_testStep:=30;
			ELSE
				m_testStep:=0;
			END_IF
		ELSE
			m_testStep:=0;
		END_IF
		
	
	30: //stop
		m_testStep:=-1;		
END_CASE
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="accuracyTest_iter" Id="{0a89f2b7-69f4-48e8-9e4f-4df31d757009}">
      <Declaration><![CDATA[METHOD accuracyTest_iter : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //data initial		
		m_targetSpatialPos:=m_targetPosArr[m_pointNum];
		m_cmdCartPose:=m_targetSpatialPos;
		numericalIK(i_slaveArm);
		
		//Determine if the error is less than the set value
		IF (norm(m_slavePosErr)<m_distErrLimit) AND (m_errAngle<m_poseErrLimit) THEN
			m_errTime:=m_errTime+g_slaveArmCtrlCycleTime;
			IF (m_errTime>m_delayTimeLimit) THEN
				m_errTime:=0;
				m_testStep:=15;
			END_IF
		ELSE
			m_errTime:=0;
		END_IF
	
		
	15: //Waiting for confirmation and measurement
		IF (GVL_AccuracyTestVar.g_nextStep[m_armId]=TRUE) THEN
			GVL_AccuracyTestVar.g_nextStep[m_armId]:=FALSE;
			m_testStep:=20;
		END_IF
		
	
	20: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_AccuracyTest.g_testMotCycNum) THEN
				m_testStep:=30;
			ELSE
				m_testStep:=0;
			END_IF
		ELSE
			m_testStep:=0;
		END_IF
	
	
	30: //stop
		m_testStep:=-1;	
		m_motionFinished:=TRUE;	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="back2origin" Id="{9ec190e9-bfb3-4e1c-bdd7-56aa92acda9b}">
      <Declaration><![CDATA[METHOD back2origin : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_startJntPos:=i_slaveArm.curJntPos;
		m_endDHPos:=m_originJntPos;		
		i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_slaveArmCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_simJntPos:=m_cmdJntPos; //copy value to sim jntpos
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;		
		m_motionFinished:=TRUE;
END_CASE


]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos" Id="{45ff5261-3263-4c0a-bada-e4386f88b1cb}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL
VAR_IN_OUT CONSTANT
	// endoscope pose in cart coordinate
	i_endoscopePose : ST_Frame;
	
	// master arm data
	i_masterStatus :ST_MasterStatus;
	
	// setup arm data
	i_setupStatus: ST_SetupStatus;
	
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	i:INT;
	tmpFrame:ST_Frame;
	r_angle:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Basic information update---front pose frame and end pose frame 
tmpFrame:=invFrame(i_endoscopePose);
i:=i_slaveArm.armIdx;
m_frontPose:=transform(tmpFrame,i_setupStatus.m_curEndPose[i]);
m_endPose.m_pos:=g_zeroVec3d;  m_endPose.m_rot:=g_eye3d;
m_slaveArmPose:=i_slaveArm.curCartPose;


//copy to global variables
GVL_AccuracyTestVar.g_frontPose[m_armId]:=m_frontPose;
GVL_AccuracyTestVar.g_endPose[m_armId]:=m_endPose;
GVL_AccuracyTestVar.g_slaveArmPose[m_armId]:=m_slaveArmPose;


//Initialization of motion parameters
m_startMotion:=GVL_AccuracyTestVar.g_startMotion[m_armId];
IF (m_startMotionLast=FALSE) AND (m_startMotion=TRUE) THEN
	motionParamInit(i_slaveArm);
END_IF
m_startMotionLast:=m_startMotion;


//Select different programs based on different control modes
IF (m_startMotion=TRUE) THEN
	IF (m_controlMode=1) THEN
		//jntSinglePoint(i_slaveArm);
		
	ELSIF (m_controlMode=2) THEN
		jntContinuousPoint(i_slaveArm);
		
	ELSIF (m_controlMode=3) THEN
		//spaceSinglePoint_iter(i_slaveArm);
		
	ELSIF (m_controlMode=4) THEN
		spaceContinuousPoint_iter(i_slaveArm);
		
	ELSIF (m_controlMode=5) THEN
		accuracyTest_iter(i_slaveArm);
		
	ELSIF (m_controlMode=6) THEN
		back2origin(i_slaveArm);
	END_IF
END_IF


//show the motion step
IF (m_controlMode=5) THEN
	GVL_AccuracyTestVar.g_curStep[m_armId]:=m_testStep;
	GVL_AccuracyTestVar.g_testPointId[m_armId]:=m_pointNum;
	GVL_AccuracyTestVar.g_testCycleId[m_armId]:=m_motionCycleNum;
ELSE
	GVL_AccuracyTestVar.g_curStep[m_armId]:=-1;
	GVL_AccuracyTestVar.g_testPointId[m_armId]:=0;
	GVL_AccuracyTestVar.g_testCycleId[m_armId]:=0;
END_IF



// feedback the motion status
IF (m_controlMode=1) OR (m_controlMode=3) OR (m_controlMode=5) OR (m_controlMode=6) THEN
	IF (m_testStep=-1) AND (m_motionFinished=TRUE) THEN
		m_controlMode:=0;
		GVL_AccuracyTestVar.g_controlMode[m_armId]:=0;	
	END_IF
ELSIF (m_controlMode=2) OR (m_controlMode=4) THEN
	IF (m_startMotion=FALSE) THEN
		m_controlMode:=0;
		GVL_AccuracyTestVar.g_controlMode[m_armId]:=0;
	END_IF
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{0d0573e4-bcf6-41e5-aaae-f56a6c51570f}">
      <Declaration><![CDATA[// override this function in each exact controller
// NOTICE: set joint control mode here, and do some initialization if needed
METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR
VAR_IN_OUT 
	r_slaveArmCtrlCmd :ST_SlaveArmCtrlCmds;	
END_VAR

VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init(i_slaveArm,r_slaveArmCtrlCmd);

//variable initialization
m_armId:=i_slaveArm.armIdx;

//motion parameters initial
motionParamInit(i_slaveArm);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntContinuousPoint" Id="{fbcb4435-cae6-4265-9904-f0248e46b86e}">
      <Declaration><![CDATA[METHOD PROTECTED jntContinuousPoint : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//joint motion incresement calculation
FOR i:=1 TO 6 BY 1 DO
	m_DHjntInc[i]:=m_DHjntInc[i]+m_jntMotionDir[i]*m_jntVel[i]*g_slaveArmCtrlCycleTime;
END_FOR

//determine DH joint position
vecAdd(m_initDHPos,m_DHjntInc,m_endDHPos);
FOR i:=1 TO 2 BY 1 DO
	m_endDHPos[i] := LIMIT(GVL_SlaveMotorParameters.g_minJntPos[i] - 5*g_deg2Rad , m_endDHPos[i], GVL_SlaveMotorParameters.g_maxJntPos[i] + 5*g_deg2Rad);
END_FOR
m_endDHPos[3] := LIMIT(GVL_SlaveMotorParameters.g_minJntPos[3] - 0.002, m_endDHPos[i], GVL_SlaveMotorParameters.g_maxJntPos[3] + 0.002);

//IK
i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);

//copy the value
m_cmdJntPos:=m_endJntPos;
m_simJntPos:=m_cmdJntPos; //copy value to sim jntpos
]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntSinglePoint" Id="{0dd167e7-64df-41a9-986a-68e28cb0e649}">
      <Declaration><![CDATA[METHOD jntSinglePoint : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_startJntPos:=i_slaveArm.curJntPos;
		m_endDHPos:=GVL_AccuracyTestVar.g_targetJntPos[m_armId];
		
		i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_slaveArmCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_simJntPos:=m_cmdJntPos; //copy value to sim jntpos
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;		
		m_motionFinished:=TRUE;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="motionParamInit" Id="{307213d8-b11a-481a-bd29-12db6287c686}">
      <Declaration><![CDATA[METHOD motionParamInit : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR
VAR
	i,j:INT;
	poseVec:Vec6d;
	originPose:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_testStep:=0;
m_time:=0;
m_controlMode:=GVL_AccuracyTestVar.g_controlMode[m_armId];
m_motionFinished:=FALSE;


//update the joint velocity
IF (m_controlMode=3) OR (m_controlMode=5) THEN
	vecMultiNum(m_DHJntVel,m_velFactor[1],m_maxDHJntVel); //low velocity
ELSIF (m_controlMode=4) THEN	
	vecMultiNum(m_DHJntVel,m_velFactor[2],m_maxDHJntVel); //high velocity
ELSE
	m_maxDHJntVel:=m_DHJntVel; //original velocity
END_IF


//joint continuous motion parameters
m_initDHPos:=i_slaveArm.curDHJntPos;
m_DHjntInc:=g_zeroVec6d;
m_jntMotionDir:=GVL_AccuracyTestVar.g_jntMotionDir[m_armId];
m_jntVel:=GVL_AccuracyTestVar.g_jntVel[m_armId];
FOR i:=1 TO 6 BY 1 DO
	m_jntVel[i]:=LIMIT(-0.1,m_jntVel[i],0.1);
END_FOR
m_jntVel[3]:=LIMIT(-0.01,m_jntVel[3],0.01);


//spatial continuous motion parameters
m_spatialMotionDir:=GVL_AccuracyTestVar.g_spatialMotionDir[m_armId];
m_spatialVel:=GVL_AccuracyTestVar.g_spatialVel[m_armId];
m_initSpatialPos:=i_slaveArm.curCartPose;
m_spatialPosInc:=g_zeroVec6d;
FOR i:=1 TO 3 BY 1 DO
	m_spatialVel[i]:=LIMIT(-0.01,m_spatialVel[i],0.01);
END_FOR
FOR i:=4 TO 6 BY 1 DO
	m_spatialVel[i]:=LIMIT(-0.1,m_spatialVel[i],0.1);
END_FOR


//velocity---acceleration---jerk
vecMultiNum(GVL_SlaveMotorParameters.g_maxJntVel,0.2,m_maxjntVel);
vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);


//accuracy test variables
m_pointNum:=1;
m_pointSum:=GVL_AccuracyTest.g_testPointNum;
m_motionCycleNum:=1;
m_errTime:=0;


//original joint position
m_originJntPos:=GVL_AccuracyTest.g_originJntPos;


//Obtain the position and posture of the test point location
FOR i:=1 TO 5 BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=GVL_AccuracyTest.g_testSpacePoint[i,j];
	END_FOR
	xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_targetPosArr[i]);
	
	i_slaveArm.forwardKinematic(i_DHJntPos:= m_originJntPos, r_cartPose:= originPose);
	m_targetPosArr[i].m_rot:=originPose.m_rot;
END_FOR


// init filter
FOR i:=1 TO 3 DO
	m_cmdJntPosLpf[i].init(1, m_macroCmdJntPosLpfCutoffFreq, g_slaveArmCtrlFreq);
END_FOR
FOR i:=4 TO g_sJntNum DO
	m_cmdJntPosLpf[i].init(1, m_microCmdJntPosLpfCutoffFreq, g_slaveArmCtrlFreq);
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="numericalIK" Id="{338e4e28-3e43-4c80-8233-1764e66a46e4}">
      <Declaration><![CDATA[METHOD numericalIK : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	i:INT;
	tmpMat3d:Mat3d;
	linearVelScale:LREAL;
	angularVelScale:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
		//Solve the error term
		vecSub(m_cmdCartPose.m_pos, i_slaveArm.simCartPose.m_pos, m_slavePosErr);
		matTranspose(i_slaveArm.simCartPose.m_rot, tmpMat3d);
		matMultiply(tmpMat3d, m_cmdCartPose.m_rot, m_slaveRotErr);
		rot2AngAxis(m_slaveRotErr, angle=>m_errAngle, axis=>m_errAxisLocal);
		matMultiVec(i_slaveArm.simCartPose.m_rot, m_errAxisLocal, m_errAxis);
		
		// pose track control
		vecMultiNum(m_slavePosErr, m_posTrackKp, m_slaveCmdVel);
		vecMultiNum(m_errAxis, m_errAngle*m_oriTrackKp, m_slaveCmdWVel);
		
		
		//Limit spatial linear velocity and angular velocity
		linearVelScale:=norm(m_slaveCmdVel)/m_linearVelLimit;
		angularVelScale:=norm(m_slaveCmdWVel)/m_angularVelLimit;	
		IF (linearVelScale)>1 THEN
			vecSelfMultiNum(m_slaveCmdVel,1.0/linearVelScale);
		END_IF
		IF (angularVelScale)>1 THEN
			vecSelfMultiNum(m_slaveCmdWVel,1.0/angularVelScale);
		END_IF
		
		
		// final command twist
		FOR i:=1 TO 3 DO 
			m_cmdCartTwist[i] := m_slaveCmdVel[i];
			m_cmdCartTwist[i+3] := m_slaveCmdWVel[i];
		END_FOR
		
		// compute command velocity for DH joints
		invJaco := i_slaveArm.simJacoInv;
		matMultiVec(invJaco, m_cmdCartTwist, m_simDHJointVel);
		
		// limit DH joints velocity and integrate command DH joint position
		FOR i:=1 TO 6 DO 
			m_simDHJointVel[i] := LIMIT(-m_maxDHJntVel[i], m_simDHJointVel[i], m_maxDHJntVel[i]);
			
			m_simDHJntPos[i] := i_slaveArm.simDHJntPos[i] + m_simDHJointVel[i]*g_slaveArmCtrlCycleTime;
			IF (m_simDHJntPos[i]>GVL_SlaveMotorParameters.g_maxDHJntPos[i]) OR (m_simDHJntPos[i]<GVL_SlaveMotorParameters.g_minDHJntPos[i]) THEN
				m_simDHJointVel[i]:=0;
				m_simDHJntPos[i] := i_slaveArm.simDHJntPos[i];
			END_IF
		END_FOR
		
		// calculate target motor joint position/velocity from DH joint position
		i_slaveArm.instrument.instruIK(m_simDHJntPos,0, o_jntPos=>m_simJntPos);
		
		// filt command joint position
		FOR i:=1 TO g_sJntNum DO 
			//m_cmdJntPos[i] := m_cmdJntPosLpf[i].run(m_simJntPos[i]);
		END_FOR
		m_cmdJntPos:=m_simJntPos;
		
						]]></ST>
      </Implementation>
    </Method>
    <Method Name="rpy2rot" Id="{2a77c0e7-fd72-47f1-a5e9-51bdfe702e1b}">
      <Declaration><![CDATA[METHOD rpy2rot : BOOL
VAR_INPUT
	i_rpy:Vec3d;
END_VAR

VAR_OUTPUT
	o_rot:Mat3d;
END_VAR

VAR
	rot_x,rot_y,rot_z:LREAL;
	alpha,beta,gama:LREAL;
	matrix_out:ARRAY[1..3,1..3] OF LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
alpha:=rot_z;
beta:=rot_y;
gama:=rot_x;

matrix_out[1,1]:=COS(alpha)*COS(beta);
matrix_out[2,1]:=SIN(alpha)*COS(beta);
matrix_out[3,1]:=-SIN(beta);

matrix_out[1,2]:=COS(alpha)*SIN(beta)*SIN(gama)-SIN(alpha)*COS(gama);
matrix_out[2,2]:=SIN(alpha)*SIN(beta)*SIN(gama)+COS(alpha)*COS(gama);
matrix_out[3,2]:=COS(beta)*SIN(gama);

matrix_out[1,3]:=COS(alpha)*SIN(beta)*COS(gama)+SIN(alpha)*SIN(gama);
matrix_out[2,3]:=SIN(alpha)*SIN(beta)*COS(gama)-COS(alpha)*SIN(gama);
matrix_out[3,3]:=COS(beta)*COS(gama);

o_rot:=matrix_out;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceContinuousPoint" Id="{3ae3ce74-e097-4489-b011-9dcbcf97ed0f}">
      <Declaration><![CDATA[METHOD spaceContinuousPoint : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	i:INT;	
	rotMatrix:Mat3d;
	tmpFrame:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
//spatial motion incresement calculation
FOR i:=1 TO 6 BY 1 DO
	m_spatialPosInc[i]:=m_spatialPosInc[i]+m_spatialMotionDir[i]*m_spatialVel[i]*g_slaveArmCtrlCycleTime;
END_FOR


//Calculate the target pose matrix
FOR i:=1 TO 3 BY 1 DO
	m_posInc[i]:=m_spatialPosInc[i];
	m_axis[i]:=m_spatialVel[i];
END_FOR
m_angle:=norm(m_spatialPosInc);
tmpFrame.m_pos:=m_posInc;
tmpFrame.m_rot:=angAxis2Rot(m_angle,m_axis);
m_targetSpatialPos:=transform(m_initSpatialPos,tmpFrame);

//Inverse kinematics solution of surgical arm
m_startDHPos:=i_slaveArm.curDHJntPos;
m_IKSucceed:=i_slaveArm.inverseKinematic(i_targetSpatialPos:= tmpFrame, i_startDHJntPos:= m_startDHPos, o_outputDHJntPos=> m_endDHPos);
IF (m_IKSucceed=FALSE) THEN
	RETURN;
END_IF

//determine joint position
i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);
m_cmdJntPos:=m_endJntPos;
*)
]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceContinuousPoint_iter" Id="{a761fe40-0c83-4c79-9e02-31b1555561ae}">
      <Declaration><![CDATA[METHOD spaceContinuousPoint_iter : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	i:INT;	
	rotMatrix:Mat3d;
	tmpFrame:ST_Frame;
	testVec6d:Vec6d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//spatial motion incresement calculation
FOR i:=1 TO 6 BY 1 DO
	m_spatialPosInc[i]:=m_spatialPosInc[i]+m_spatialMotionDir[i]*m_spatialVel[i]*g_slaveArmCtrlCycleTime;
END_FOR

//Calculate the target pose matrix
FOR i:=1 TO 3 BY 1 DO
	m_posInc[i]:=m_spatialPosInc[i];
	m_axis[i]:=m_spatialMotionDir[i+3];
END_FOR
m_angle:=norm(m_spatialPosInc);
tmpFrame.m_pos:=m_posInc;
tmpFrame.m_rot:=angAxis2Rot(m_angle,m_axis);
m_targetSpatialPos:=transform(m_initSpatialPos,tmpFrame);

// Numerical method for inverse solution
m_cmdCartPose:=m_targetSpatialPos;
numericalIK(i_slaveArm);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceSinglePoint" Id="{57935730-d3e0-49a0-a5e7-5322f40a77c8}">
      <Declaration><![CDATA[METHOD spaceSinglePoint : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(*
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_targetSpatialPos:=GVL_AccuracyTestVar.g_targetSpatialPos[m_armId];
		m_startDHPos:=i_slaveArm.curDHJntPos;
		m_IKSucceed:=i_slaveArm.inverseKinematic(i_targetSpatialPos:= m_targetSpatialPos, i_startDHJntPos:= m_startDHPos, o_outputDHJntPos=> m_endDHPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=20;
		END_IF
		
		m_startJntPos:=i_slaveArm.curJntPos;		
		i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_slaveArmCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;		
END_CASE
*)
]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceSinglePoint_iter" Id="{e95481d5-fc1a-4f39-b6aa-ed5875ff2314}">
      <Declaration><![CDATA[METHOD spaceSinglePoint_iter : BOOL
VAR_INPUT
	// slave arm data
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	tmpMat3d:Mat3d;
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Numerical method for inverse solution
		m_targetSpatialPos:=GVL_AccuracyTestVar.g_targetSpatialPos[m_armId];
		m_cmdCartPose:=m_targetSpatialPos;
		numericalIK(i_slaveArm);
		
		//Determine if the error is less than the set value
		IF (norm(m_slavePosErr)<m_distErrLimit) AND (m_errAngle<m_poseErrLimit) THEN
			m_errTime:=m_errTime+g_slaveArmCtrlCycleTime;
			IF (m_errTime>m_delayTimeLimit) THEN
				m_errTime:=0;
				m_testStep:=10;
			END_IF
		ELSE
			m_errTime:=0;
		END_IF
		
		
	10: //end the motion
		m_testStep:=-1;	
		m_motionFinished:=TRUE;	
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="xyzrpy2Frame" Id="{386a3d45-d2c1-4c32-a59e-a596651a6100}">
      <Declaration><![CDATA[METHOD xyzrpy2Frame : BOOL
VAR_INPUT
	i_posVec:Vec6d;
END_VAR

VAR_OUTPUT
	o_frame:ST_Frame;
END_VAR

VAR
	i:INT;
	rpyVec:Vec3d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i:=1 TO 3 BY 1 DO
	o_frame.m_pos[i]:=i_posVec[i];
	rpyVec[i]:=i_posVec[i+3];
END_FOR
rpy2rot(i_rpy:= rpyVec, o_rot=> o_frame.m_rot) ;

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SlaveCtrlPrecisionTest">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.accuracyTest">
      <LineId Id="109" Count="0" />
      <LineId Id="45" Count="2" />
      <LineId Id="60" Count="0" />
      <LineId Id="100" Count="3" />
      <LineId Id="50" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="65" Count="6" />
      <LineId Id="63" Count="1" />
      <LineId Id="51" Count="1" />
      <LineId Id="74" Count="3" />
      <LineId Id="72" Count="1" />
      <LineId Id="54" Count="1" />
      <LineId Id="78" Count="0" />
      <LineId Id="80" Count="1" />
      <LineId Id="83" Count="2" />
      <LineId Id="87" Count="1" />
      <LineId Id="86" Count="0" />
      <LineId Id="115" Count="1" />
      <LineId Id="82" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="89" Count="2" />
      <LineId Id="58" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.accuracyTest_iter">
      <LineId Id="45" Count="2" />
      <LineId Id="60" Count="0" />
      <LineId Id="116" Count="11" />
      <LineId Id="114" Count="1" />
      <LineId Id="133" Count="0" />
      <LineId Id="136" Count="3" />
      <LineId Id="134" Count="1" />
      <LineId Id="54" Count="1" />
      <LineId Id="78" Count="0" />
      <LineId Id="80" Count="1" />
      <LineId Id="83" Count="2" />
      <LineId Id="87" Count="1" />
      <LineId Id="86" Count="0" />
      <LineId Id="145" Count="1" />
      <LineId Id="82" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="89" Count="2" />
      <LineId Id="152" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.back2origin">
      <LineId Id="6" Count="0" />
      <LineId Id="9" Count="15" />
      <LineId Id="44" Count="0" />
      <LineId Id="25" Count="6" />
      <LineId Id="38" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.calcCmdJntPos">
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="69" Count="2" />
      <LineId Id="45" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="24" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="97" Count="2" />
      <LineId Id="96" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="80" Count="1" />
      <LineId Id="103" Count="0" />
      <LineId Id="82" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="84" Count="1" />
      <LineId Id="105" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="106" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="107" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="77" Count="1" />
      <LineId Id="129" Count="1" />
      <LineId Id="132" Count="2" />
      <LineId Id="158" Count="1" />
      <LineId Id="135" Count="1" />
      <LineId Id="160" Count="1" />
      <LineId Id="131" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="354" Count="0" />
      <LineId Id="220" Count="0" />
      <LineId Id="223" Count="10" />
      <LineId Id="221" Count="1" />
      <LineId Id="255" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.init">
      <LineId Id="12" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.jntContinuousPoint">
      <LineId Id="21" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="11" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="53" Count="2" />
      <LineId Id="52" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.jntSinglePoint">
      <LineId Id="57" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="55" Count="1" />
      <LineId Id="44" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="26" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="58" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.motionParamInit">
      <LineId Id="10" Count="2" />
      <LineId Id="95" Count="0" />
      <LineId Id="106" Count="2" />
      <LineId Id="110" Count="1" />
      <LineId Id="113" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="115" Count="1" />
      <LineId Id="112" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="13" Count="5" />
      <LineId Id="128" Count="2" />
      <LineId Id="79" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="19" Count="5" />
      <LineId Id="131" Count="1" />
      <LineId Id="80" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="133" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="25" Count="4" />
      <LineId Id="81" Count="0" />
      <LineId Id="30" Count="5" />
      <LineId Id="82" Count="0" />
      <LineId Id="65" Count="2" />
      <LineId Id="83" Count="0" />
      <LineId Id="36" Count="10" />
      <LineId Id="84" Count="0" />
      <LineId Id="47" Count="7" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.numericalIK">
      <LineId Id="54" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="12" Count="9" />
      <LineId Id="113" Count="0" />
      <LineId Id="105" Count="7" />
      <LineId Id="103" Count="1" />
      <LineId Id="114" Count="0" />
      <LineId Id="22" Count="11" />
      <LineId Id="66" Count="1" />
      <LineId Id="35" Count="12" />
      <LineId Id="9" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="79" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.rpy2rot">
      <LineId Id="7" Count="0" />
      <LineId Id="21" Count="7" />
      <LineId Id="30" Count="2" />
      <LineId Id="34" Count="3" />
      <LineId Id="39" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.spaceContinuousPoint">
      <LineId Id="11" Count="0" />
      <LineId Id="19" Count="3" />
      <LineId Id="47" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="39" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.spaceContinuousPoint_iter">
      <LineId Id="11" Count="0" />
      <LineId Id="19" Count="3" />
      <LineId Id="31" Count="1" />
      <LineId Id="39" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.spaceSinglePoint">
      <LineId Id="96" Count="0" />
      <LineId Id="74" Count="21" />
      <LineId Id="37" Count="4" />
      <LineId Id="48" Count="0" />
      <LineId Id="42" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.spaceSinglePoint_iter">
      <LineId Id="9" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="136" Count="1" />
      <LineId Id="139" Count="1" />
      <LineId Id="144" Count="0" />
      <LineId Id="141" Count="2" />
      <LineId Id="138" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="42" Count="1" />
      <LineId Id="156" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlPrecisionTest.xyzrpy2Frame">
      <LineId Id="7" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>