<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_SlaveCtrlScopeToggle" Id="{7f91246f-ffc7-4fcd-9845-791ccec5d233}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: toggle endoscope posture
FUNCTION_BLOCK PUBLIC FB_SlaveCtrlScopeToggle EXTENDS FB_SlaveArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	// target joint position
	m_targetRotJntPos :LREAL;
	
	// motion planning
	m_jntOTG : FB_secOrdTrajFilter;
	m_rotVel :LREAL := 2*pi;
	m_rotAcc :LREAL := 6*pi;
	
	// as there are two types scope holder, need to determin the rotate joint index
	m_scopeRotJntIdx: INT;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="calcCmdJntPos" Id="{4704cbbf-ddb4-420b-95f0-63ea38350051}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL
VAR_IN_OUT CONSTANT
	i_endoscopePose : ST_Frame;
	i_masterStatus :ST_MasterStatus;
	i_setupStatus: ST_SetupStatus;
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR 
	i :INT;
	trackErr:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// traj plan
m_jntOTG.run(m_targetRotJntPos, 0.0, o_cmdAcc=>m_cmdJntAcc[m_scopeRotJntIdx],o_cmdVel=>m_cmdJntVel[m_scopeRotJntIdx],o_cmdPos=>m_cmdJntPos[m_scopeRotJntIdx]);

// joint6 output torque to help rotation motion
IF m_jntOPMode[6] = DriverOPMode_Trq THEN
	m_cmdJntTrq[6] := -0.5*i_slaveArm.cmdJntTrq[7];
END_IF

// reach target check
trackErr := ABS(i_slaveArm.curJntPos[m_scopeRotJntIdx] - m_targetRotJntPos);
m_isFinished := trackErr <g_jntCtrlAngTolHigh/2 AND i_slaveArm.curJntVel[m_scopeRotJntIdx]<g_jntStaticVelThres;]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{d6394fcd-e49b-40e7-837c-8d44a4853971}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR
VAR_IN_OUT 
	r_slaveArmCtrlCmd :ST_SlaveArmCtrlCmds;
END_VAR

VAR
	i:INT;
	cycleNum:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// check if to hold the command joint position unchanged
m_holdLastCmds := checkToHoldLastCmds(i_slaveArm);

SUPER^.Init(i_slaveArm,r_slaveArmCtrlCmd);
m_jntOPMode[6] := DriverOPMode_PosTrq;
m_jntOPMode[7] := DriverOPMode_PosTrq;
m_jntOPMode[8] := DriverOPMode_PosTrq;

IF i_slaveArm.instrument.onChipData.m_InstruID = InstruType_NewEndoscope THEN
	m_scopeRotJntIdx :=7;
	m_jntOPMode[6] := DriverOPMode_Trq;
ELSE
	m_scopeRotJntIdx:=8;
END_IF

// endoscope posture toggle
IF i_slaveArm.instrument.nextScopePosture <> i_slaveArm.instrument.curScopePosture AND i_slaveArm.instrument.curScopeType = EndoScopeType_30 THEN
	IF i_slaveArm.instrument.nextScopePosture = EndoScopePosture_HeadDown THEN
		m_targetRotJntPos := m_cmdJntPos[m_scopeRotJntIdx] + PI/i_slaveArm.instrument.m_endoscopeRotateReduction;
	ELSE
		m_targetRotJntPos := m_cmdJntPos[m_scopeRotJntIdx] - PI/i_slaveArm.instrument.m_endoscopeRotateReduction;
	END_IF
ELSE
	m_targetRotJntPos := m_cmdJntPos[m_scopeRotJntIdx];
END_IF

// init traj filter
m_jntOTG.init(m_cmdJntPos[m_scopeRotJntIdx], 0, m_rotVel, m_rotAcc, g_slaveArmCtrlCycleTime);

// update endoscope type/posture
i_slaveArm.instrument.curScopeType := i_slaveArm.instrument.nextScopeType;
i_slaveArm.instrument.curScopePosture := i_slaveArm.instrument.nextScopePosture;

// update commands to arm
copyCmds(r_slaveArmCtrlCmd);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SlaveCtrlScopeToggle">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlScopeToggle.calcCmdJntPos">
      <LineId Id="293" Count="9" />
      <LineId Id="211" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlScopeToggle.init">
      <LineId Id="346" Count="33" />
      <LineId Id="191" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>