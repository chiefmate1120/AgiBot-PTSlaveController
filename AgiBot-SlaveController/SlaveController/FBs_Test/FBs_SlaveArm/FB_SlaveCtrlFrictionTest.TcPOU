<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_SlaveCtrlFrictionTest" Id="{85b64969-efb8-46ec-b345-489d013d7aed}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: Slave Arm test
FUNCTION_BLOCK PUBLIC FB_SlaveCtrlFrictionTest EXTENDS FB_SlaveArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR

VAR CONSTANT
	//max number of data recording points
	//3deg/s(360dge)=120s
	//record cycle(0.001s)
	m_dataSum:INT:=13000;
	m_JntNum:INT:=6;
END_VAR

VAR
	//arm id
	m_armId:INT;
	
	//test step
	m_testStep:INT:=-1;
	
	//start motion
	m_startMotion:BOOL;
	m_startMotionLast:BOOL;
	
	//test joint id
	m_jntId:INT;
	
	//trajectory id
	m_trajId:INT;
	
	//home position
	m_homeDHPos:Vec6d;
	m_startDHJntPos:Vec6d;
	m_endDHJntPos:Vec6d;
	
	//joint LimitBuffer
	m_limitBuffer:LREAL:=0.0*g_deg2Rad;
	
	//basic function
	m_basicFun:FB_BasicFun;
	
	//DH joint position	
	m_targetDHPos :Vec6d;
	
	//startJntPos,endJntPos :Vec8d;
	m_startJntPos,m_endJntPos :Vec8d;
	
	//Trajectory planner
	m_Planner: FB_TrajMoveJ;
	
	//motion parameters
	m_maxjntVel,m_maxjntAcc,m_maxjntJerk:Vec8d;
	
	//time
	m_time:LREAL;
	
	//data sum
	m_dataRecordSum:INT;
	
	//motion status
	m_motionFinished:BOOL;
	
	//sampling interval
	m_samplingInterval:INT:=4;
	
	//discard time
	m_discardDuration:LREAL:=1;
	
	//Number of data records
	m_RecordNumD2,m_RecordNumD3,m_RecordNumD2Init:ARRAY[1..6] OF INT;
	
	//valid number
	m_validNum:ARRAY[1..6] OF INT;
	
	//joint gap
	m_jntGap,m_jntGapInit:ARRAY[1..6] OF LREAL;
	
	//The current values of the second and third trajectories
	m_cmdDHJntPosD2,m_jntPosD2,m_jntTrqD2,m_jntCurD2,m_jntCurD2_Init:ARRAY[1..6,1..gvl_const.g_recordDataNum] OF LREAL;
	m_cmdDHJntPosD3,m_jntPosD3,m_jntTrqD3,m_jntCurD3,m_jntCurD3_Init:ARRAY[1..6,1..gvl_const.g_recordDataNum] OF LREAL;
	m_jntTrqD3_Reverse,m_jntCurD3_Reverse:ARRAY[1..6,1..gvl_const.g_recordDataNum] OF LREAL;
	
	//friction record value
	m_CoulombFriction,m_CoulombFrictionInit:ARRAY[1..6,1..gvl_const.g_recordDataNum] OF LREAL;
	m_CoulombFrictionSum,m_CoulombFrictionSumInit:ARRAY[1..6] OF LREAL;
	m_CoulombFrictionAve,m_CoulombFrictionRatio:ARRAY[1..6] OF LREAL;
	
	//max joint friction and it's joint position
	m_CoulombFrictionMax,m_CoulombFrictionMax_JntPos:ARRAY[1..g_sJntNum] OF LREAL;
	
	//counter
	m_counter:INT;
	m_pointNum:INT;
	m_pointNumLast:INT;	
	
	//unit transform
	m_unitTransform:FB_UnitTransform;	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="basicTestMotion" Id="{7950f769-3cb6-4ae2-a084-83b88f387976}">
      <Declaration><![CDATA[METHOD basicTestMotion : BOOL
VAR_INPUT
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR
	i,j,k:INT;
	id:INT;
	validNum:INT;	
	gap:LREAL;
	curDHJntPos:Vec6d;
	ratio:LREAL;
	cmdGripAngle:LREAL;
	m_startDHPos,m_endDHPos :Vec6d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF 
	0: //init the trajectory
		g_frictionTest.m_jntIdStart[m_armId]:=LIMIT(1,g_frictionTest.m_jntIdStart[m_armId],3);
		g_frictionTest.m_jntIdEnd[m_armId]:=LIMIT(1,g_frictionTest.m_jntIdEnd[m_armId],3);
		
		m_jntId:=g_frictionTest.m_jntIdStart[m_armId];
		m_trajId:=1;
		m_jntCurD2:=m_jntCurD2_Init;		m_jntTrqD2:=m_jntCurD2_Init;		m_jntPosD2:=m_jntCurD2_Init;
		m_jntCurD3:=m_jntCurD3_Init;		m_jntTrqD3:=m_jntCurD3_Init;		m_jntPosD3:=m_jntCurD3_Init;
		m_CoulombFriction:=m_CoulombFrictionInit;
		
		m_CoulombFrictionSum:=m_CoulombFrictionSumInit;
		m_jntGap:=m_jntGapInit;
		m_RecordNumD2:=m_RecordNumD2Init; m_RecordNumD3:=m_RecordNumD2Init;
		m_motionFinished:=FALSE;
		m_testStep:=10;
		
		
	10: //Plan the trajectory		
		curDHJntPos:=i_slaveArm.curDHJntPos;		
		m_startDHPos:=m_homeDHPos;
		m_endDHPos:=m_homeDHPos;
		
		IF (m_trajId=1) THEN
			//m_startDHPos[m_jntId]:=curDHJntPos[m_jntId];
			m_startDHPos:=curDHJntPos;
			m_endDHPos[m_jntId]:=m_startDHJntPos[m_jntId];
		ELSIF (m_trajId=2) THEN
			m_startDHPos[m_jntId]:=m_startDHJntPos[m_jntId];
			m_endDHPos[m_jntId]:=m_endDHJntPos[m_jntId];
		ELSIF (m_trajId=3) THEN
			m_startDHPos[m_jntId]:=m_endDHJntPos[m_jntId];
			m_endDHPos[m_jntId]:=m_startDHJntPos[m_jntId];
		ELSIF (m_trajId=4) THEN
			m_startDHPos[m_jntId]:=m_startDHJntPos[m_jntId];
			m_endDHPos[m_jntId]:=m_homeDHPos[m_jntId];
		END_IF
		
		//m_startJntPos,m_endJntPos
		IF (i_slaveArm.instrument.m_instruType=InstruType_UNKNOWM) THEN
			FOR i:=1 TO 3 BY 1 DO
				m_startJntPos[i]:=m_startDHPos[i];
				m_endJntPos[i]:=m_endDHPos[i];
			END_FOR
			FOR i:=4 TO 8 BY 1 DO
				m_startJntPos[i]:=i_slaveArm.curJntPos[i];
				m_endJntPos[i]:=i_slaveArm.curJntPos[i];
			END_FOR
		ELSE
			i_slaveArm.instrument.instruIK(m_startDHPos,0, o_jntPos=>m_startJntPos);
			i_slaveArm.instrument.instruIK(m_endDHPos,0, o_jntPos=>m_endJntPos);			
		END_IF		
		
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_time:=0; m_testStep:=50;
		ELSE
			m_time:=0; m_testStep:=20;
			m_dataRecordSum:=0;
			m_counter:=0;
			m_pointNum:=0;
			m_pointNumLast:=0;
		END_IF
		
		
	20: //start the motion
		m_time:=m_time+g_slaveArmCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=30;
		END_IF
		
		//add code for instrument joint
		FOR i:=4 TO 8 BY 1 DO
			m_cmdJntPos[i]:=i_slaveArm.curJntPos[i];
		END_FOR						
		
		//updata the value of counter
		m_counter:=m_counter+1;
		IF (m_counter>=4*20) THEN
			m_counter:=0;
			m_pointNum:=m_pointNum+1;
		END_IF
		
		//Discard the first and last paragraphs of data
		IF (m_time<m_discardDuration) OR (m_time>(m_Planner.duration-m_discardDuration)) THEN
			m_counter:=0;
			m_pointNum:=m_pointNumLast;
		END_IF
		m_pointNumLast:=m_pointNum;
		
		//current DH joint position
		curDHJntPos:=i_slaveArm.curDHJntPos;	
		
		//command DH joint position
		i_slaveArm.instrument.instruFK(m_cmdJntPos,m_targetDHPos,cmdGripAngle);
		
		//record the data---Move in the positive direction
		IF (m_trajId=2) AND (m_counter=0) AND (m_pointNum<=gvl_const.g_recordDataNum) AND (m_pointNum>0) THEN
			m_RecordNumD2[m_jntId]:=m_pointNum;
			m_jntCurD2[m_jntId,m_pointNum]:=i_slaveArm.filtJntCurrent[m_jntId]*GVL_SlaveMotorParameters.g_motorDir[m_jntId];
			m_jntTrqD2[m_jntId,m_pointNum]:=i_slaveArm.curJntTrq[m_jntId];
			m_jntPosD2[m_jntId,m_pointNum]:=curDHJntPos[m_jntId];
			m_cmdDHJntPosD2[m_jntId,m_pointNum]:=m_targetDHPos[m_jntId];
			
			g_frictionTest.m_cmdDHJntPosD2[m_armId,m_jntId,m_pointNum]:=m_cmdDHJntPosD2[m_jntId,m_pointNum];
			g_frictionTest.m_jntPosD2[m_armId,m_jntId,m_pointNum]:=m_jntPosD2[m_jntId,m_pointNum];
			g_frictionTest.m_jntTrqD2[m_armId,m_jntId,m_pointNum]:=m_jntTrqD2[m_jntId,m_pointNum];
		END_IF
		
		//record the data---Move in the negative direction
		IF (m_trajId=3) AND (m_counter=0) AND (m_pointNum<=gvl_const.g_recordDataNum) AND (m_pointNum>0) THEN
			m_RecordNumD3[m_jntId]:=m_pointNum;
			m_jntCurD3[m_jntId,m_pointNum]:=i_slaveArm.filtJntCurrent[m_jntId]*GVL_SlaveMotorParameters.g_motorDir[m_jntId];
			m_jntTrqD3[m_jntId,m_pointNum]:=i_slaveArm.curJntTrq[m_jntId];
			m_jntPosD3[m_jntId,m_pointNum]:=curDHJntPos[m_jntId];
			m_cmdDHJntPosD3[m_jntId,m_pointNum]:=m_targetDHPos[m_jntId];
			
			g_frictionTest.m_cmdDHJntPosD3[m_armId,m_jntId,m_pointNum]:=m_cmdDHJntPosD3[m_jntId,m_pointNum];
			g_frictionTest.m_jntPosD3[m_armId,m_jntId,m_pointNum]:=m_jntPosD3[m_jntId,m_pointNum];
			g_frictionTest.m_jntTrqD3[m_armId,m_jntId,m_pointNum]:=m_jntTrqD3[m_jntId,m_pointNum];
		END_IF
		
		//update the joint gap
		FOR i:=1 TO m_JntNum BY 1 DO
			gap:=ABS(i_slaveArm.curJntPos[i]-i_slaveArm.curLinkPos[i]);
			IF (gap>m_jntGap[i]) THEN
				m_jntGap[i]:=gap;
			END_IF
		END_FOR
		
		//output the joint gap
		//g_frictionTest.m_jntGap[m_armId]:=m_jntGap;
		g_frictionTest.m_jntGap[m_armId]:=m_unitTransform.slaveArmUnit2User(m_jntGap);
		
		
	30: //Update joint and trajectory numbers
		m_trajId:=m_trajId+1;
		IF (m_trajId<=4) THEN			
			m_testStep:=10;
		ELSE
			m_testStep:=40;
		END_IF
		
		
	40: //Calculate technical indicators
		i:=m_jntId;
		
		//FOR i:=1 TO m_JntNum BY 1 DO
			IF (m_RecordNumD2[i]>m_RecordNumD3[i]) THEN
				validNum:=m_RecordNumD3[i];
			ELSE
				validNum:=m_RecordNumD2[i];
			END_IF
			m_validNum[i]:=validNum;
			
			//Sort the third test data in reverse order
			FOR j:=1 TO validNum BY 1 DO
				id:=m_RecordNumD3[i]-j+1;
				m_jntCurD3_Reverse[i,j]:=m_jntCurD3[i,id];
				m_jntTrqD3_Reverse[i,j]:=m_jntTrqD3[i,id];
			END_FOR
			
			//Calculate frictional force
			FOR j:=1 TO validNum BY 1 DO
				//for positive direciton:T2=G+F-----for nagative direction:T3=G-F,  so F=(T2-T3)/2---G=(T2+T3)/2
				m_CoulombFriction[i,j]:=(m_jntTrqD2[i,j]-m_jntTrqD3_Reverse[i,j])/2;
				m_CoulombFrictionSum[i]:=m_CoulombFrictionSum[i]+m_CoulombFriction[i,j];										
			END_FOR		
			
			//calculate the max joint friction
			m_CoulombFrictionMax[i]:=m_CoulombFriction[i,1];
			m_CoulombFrictionMax_JntPos[i]:=m_jntPosD2[i,1];
			FOR j:=1 TO validNum BY 1 DO
				IF (m_CoulombFriction[i,j]>m_CoulombFrictionMax[i]) THEN
					m_CoulombFrictionMax[i]:=m_CoulombFriction[i,j];
					m_CoulombFrictionMax_JntPos[i]:=m_jntPosD2[i,j];
				END_IF
			END_FOR
						
			//calculate the average of friction and ratio
			m_CoulombFrictionRatio[i]:=0;
			m_CoulombFrictionAve[i]:=m_CoulombFrictionSum[i]/validNum;
			FOR j:=1 TO validNum BY 1 DO
				ratio:=m_CoulombFriction[i,j]/m_CoulombFrictionSum[i];
				IF (ratio>0) AND (ratio>m_CoulombFrictionRatio[i]) THEN
					m_CoulombFrictionRatio[i]:=ratio;
				END_IF
			END_FOR
			g_frictionTest.m_CoulombFrictionAve[m_armId,i]:=m_CoulombFrictionAve[i];
			g_frictionTest.m_CoulombFrictionRatio[m_armId,i]:=m_CoulombFrictionRatio[i];		
		//END_FOR			
		
		//output to global variables		
		g_frictionTest.m_CoulombFrictionMax[m_armId]:=m_CoulombFrictionMax;
		g_frictionTest.m_CoulombFrictionMax_JntPos[m_armId]:=m_unitTransform.slaveArmUnit2UserN8(i_dataSystem:= m_CoulombFrictionMax_JntPos);
		
		//next step
		m_testStep:=50;
		
		
	50: //update the joint id
		m_jntId:=m_jntId+1;
		m_trajId:=1;
		IF (m_jntId<=g_frictionTest.m_jntIdEnd[m_armId]) THEN
			m_testStep:=10;
		ELSE
			m_testStep:=60;
		END_IF
				
		
	60:
		m_testStep:=-1;
		m_motionFinished:=TRUE;
		//g_frictionTest.m_writeData[m_armId]:=TRUE; //output the data to txt file
		
		
	-1: //	
END_CASE


//output the test information
g_frictionTest.m_jntId[m_armId]:=m_jntId;
g_frictionTest.m_trajId[m_armId]:=m_trajId;
g_frictionTest.m_testStep[m_armId]:=m_testStep;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos" Id="{5c8f237a-0c1f-470d-9727-bb740d00d00f}">
      <Declaration><![CDATA[METHOD PROTECTED calcCmdJntPos : BOOL
VAR_IN_OUT CONSTANT
	i_endoscopePose : ST_Frame;
	i_masterStatus :ST_MasterStatus;
	i_setupStatus: ST_SetupStatus;
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR 
	//
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//show the joint angle
g_frictionTest.m_armActJntPos[m_armId]:=m_unitTransform.slaveArmUnit2UserN8(i_dataSystem:= i_slaveArm.curJntPos);
g_frictionTest.m_armDHJntPos[m_armId]:=m_unitTransform.slaveArmUnit2User(i_dataSystem:= i_slaveArm.curDHJntPos);

//start motion flag
m_startMotion:=g_frictionTest.m_startMotion[m_armId];
IF (m_startMotionLast=FALSE) AND (m_startMotion=TRUE) THEN
	m_testStep:=0;
	m_motionFinished:=FALSE;
END_IF
m_startMotionLast:=m_startMotion;


//transform to arm test motion
IF (m_startMotion=TRUE) THEN
	basicTestMotion(i_slaveArm);
END_IF


//return the motion status
IF (m_testStep=-1) AND (m_motionFinished=TRUE) THEN
	g_frictionTest.m_startMotion[m_armId]:=FALSE;		
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq" Id="{53b2bde5-bbc2-4fa9-bf3d-08ff38b9469c}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq : BOOL
VAR_IN_OUT CONSTANT
	i_endoscopePose : ST_Frame;
	i_masterStatus :ST_MasterStatus;
	i_setupStatus: ST_SetupStatus;
	i_slaveArm :FB_SlaveArm;
END_VAR

VAR 
	i:INT;
	instruCmdJntPos, instruCmdJntVel : Vec5d;	
	instruJntCtrlTrq :Vec5d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{ff7ffc42-d32e-42f9-a734-887055e6b248}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR
VAR_IN_OUT 
	r_slaveArmCtrlCmd :ST_SlaveArmCtrlCmds;
END_VAR
VAR
	i:INT;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init(i_slaveArm,r_slaveArmCtrlCmd);

(*
m_jntOPMode[1] := DriverOPMode_PosTrq;
m_jntOPMode[2] := DriverOPMode_PosTrq;
m_jntOPMode[3] := DriverOPMode_PosTrq;
m_jntOPMode[4] := DriverOPMode_Trq;
m_jntOPMode[5] := DriverOPMode_Trq;
m_jntOPMode[6] := DriverOPMode_Trq;
m_jntOPMode[7] := DriverOPMode_Trq;
m_jntOPMode[8] := DriverOPMode_Trq;
*)

// update commands to arm
copyCmds(r_slaveArmCtrlCmd);


//init basic parameters
m_armId:=i_slaveArm.armIdx;
m_startMotionLast:=FALSE;


//joint home position---joint motion start position and end position
FOR i:=1 TO 6 BY 1 DO
	m_homeDHPos[i]:=(GVL_SlaveMotorParameters.g_maxDHJntPos[i]+GVL_SlaveMotorParameters.g_minDHJntPos[i])/2;
	m_startDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i]+m_limitBuffer;
	m_endDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i]-m_limitBuffer;	
END_FOR
m_homeDHPos[2]:=-pi/2;


//joint velocity and acceleration
FOR i:=1 TO 8 BY 1 DO
	m_maxjntVel[i]:=3.0*g_deg2rad;
END_FOR
m_maxjntVel[3]:=0.005;
vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SlaveCtrlFrictionTest">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlFrictionTest.basicTestMotion">
      <LineId Id="7" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="278" Count="0" />
      <LineId Id="280" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="23" Count="4" />
      <LineId Id="31" Count="8" />
      <LineId Id="251" Count="0" />
      <LineId Id="42" Count="4" />
      <LineId Id="281" Count="0" />
      <LineId Id="47" Count="11" />
      <LineId Id="256" Count="0" />
      <LineId Id="353" Count="1" />
      <LineId Id="360" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="361" Count="0" />
      <LineId Id="364" Count="2" />
      <LineId Id="363" Count="0" />
      <LineId Id="356" Count="0" />
      <LineId Id="358" Count="1" />
      <LineId Id="355" Count="0" />
      <LineId Id="254" Count="0" />
      <LineId Id="59" Count="14" />
      <LineId Id="335" Count="1" />
      <LineId Id="333" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="334" Count="0" />
      <LineId Id="329" Count="0" />
      <LineId Id="331" Count="1" />
      <LineId Id="79" Count="15" />
      <LineId Id="96" Count="0" />
      <LineId Id="261" Count="1" />
      <LineId Id="259" Count="0" />
      <LineId Id="257" Count="0" />
      <LineId Id="97" Count="36" />
      <LineId Id="282" Count="0" />
      <LineId Id="134" Count="5" />
      <LineId Id="146" Count="2" />
      <LineId Id="158" Count="1" />
      <LineId Id="294" Count="1" />
      <LineId Id="160" Count="19" />
      <LineId Id="190" Count="1" />
      <LineId Id="299" Count="7" />
      <LineId Id="296" Count="1" />
      <LineId Id="192" Count="10" />
      <LineId Id="228" Count="0" />
      <LineId Id="232" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="312" Count="1" />
      <LineId Id="307" Count="0" />
      <LineId Id="233" Count="3" />
      <LineId Id="283" Count="0" />
      <LineId Id="288" Count="5" />
      <LineId Id="284" Count="1" />
      <LineId Id="287" Count="0" />
      <LineId Id="237" Count="13" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlFrictionTest.calcCmdJntPos">
      <LineId Id="379" Count="0" />
      <LineId Id="381" Count="1" />
      <LineId Id="332" Count="0" />
      <LineId Id="343" Count="0" />
      <LineId Id="360" Count="5" />
      <LineId Id="113" Count="0" />
      <LineId Id="367" Count="4" />
      <LineId Id="366" Count="0" />
      <LineId Id="373" Count="4" />
      <LineId Id="372" Count="0" />
      <LineId Id="378" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlFrictionTest.calcCmdJntTrq">
      <LineId Id="195" Count="0" />
      <LineId Id="213" Count="0" />
      <LineId Id="212" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlaveCtrlFrictionTest.init">
      <LineId Id="13" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="86" Count="6" />
      <LineId Id="19" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="110" Count="1" />
      <LineId Id="109" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="146" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="163" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="160" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="150" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="166" Count="3" />
      <LineId Id="185" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="164" Count="1" />
      <LineId Id="12" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>