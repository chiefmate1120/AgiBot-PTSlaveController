<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_Instrument" Id="{8c0067f5-f42b-4462-b105-279d3ba7139d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Instrument

VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR

VAR
	// instrument type
	m_instruType : 	E_InstrumentType := InstruType_UNKNOWM;
	
	// instrument type info
	m_instruTypeInfo : 	ST_InstruTypeInfo;
	
	//The state and parameters readed from the instrument
	m_onChipData:ST_InstruOnChipData;
	
	// current and max allowed read tries
	m_curReadTries :INT :=0;
	m_maxReadTries :INT := 2;
	
	//IP of operating arm
	m_armNetId:T_AmsNetId; 
	m_setupArmNetId:T_AmsNetId; 	
	
	//Joint port number
	m_jointInstruAddr:UINT;	
	
	//LED port address
	m_LEDAddr:UINT;		

	// joint position when instrument is at ZERO posture
	m_jntPosOffset:Vec8d;
	
	// instrument wrist DH joint limit
	m_wristMinDHJntPos :Vec3d;
	m_wristMaxDHJntPos :Vec3d;
	
	// reduction from motor joint to endoscope rotate joint
	m_endoscopeRotateReduction :LREAL := 2.0/3.0;
	
	// endoscope rotation joint index
	m_endoscopeRotJntIdx :INT :=8;
	
	//endoscope type
	m_curEndoscopeType :E_EndoscopeType:=EndoScopeType_30;
	m_nextEndoscopeType :E_EndoscopeType:=EndoScopeType_30;
	
	//endoscope posutre
	m_curEndoscopePosture :E_EndoscopePosture:=EndoscopePosture_HeadDown;
	m_nextEndoscopePosture :E_EndoscopePosture:=EndoscopePosture_HeadDown;
	
	// udint code for zero position
	m_zeroPosCode : UDINT;
	
	// joint4 zero position, which is supposed to be a contant value
	m_jnt4ZeroPos :LREAL := 5.7;
	
	//reset arm  LED flag
	m_resetArmLEDFlag : BOOL :=TRUE;
	
	// variables used to read instrument information
	m_Step:INT;
	m_Value:UDINT;
	m_ReadDelay:TON;
	m_DealyTime:TIME:=T#0.5S;
	m_IDReadResult:UDINT;
	m_IDResult:ULINT;
	m_SeriesReadResult:UDINT;
	m_PosReadResult:UDINT;
	m_PosL1,m_PosL2,m_PosL3:UDINT;
	m_signL1,m_signL2,m_signL3:UDINT;
	m_UsageReadResult:ULINT;
	m_InstruUsageToLED:ULINT;
	
	m_HaveRecord:BOOL;
	m_SdoWrite:FB_EcCoESdoWrite;
	m_SdoRead:FB_EcCoESdoRead;
	
	//variables used to read-write instrument number of use
	m_useNumStep : INT;
	m_ReadNumDelay:TON;
	m_useNumReadResult:ULINT;
	m_useNumSendToLED:ULINT;
	
	// rising edge generator for instrument information reading
	m_writeLDP:R_TRIG;
	
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="property" Id="{9d49480e-8469-42fe-9794-09bbda49b553}" />
    <Method Name="checkInstruType" Id="{97020e4c-24ed-4bb8-b0ec-bca5a733a6da}">
      <Declaration><![CDATA[METHOD PROTECTED checkInstruType : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// search instrument type
checkInstruType :=FALSE;
FOR i:=1 TO g_instruTypeNum DO 
	IF g_instruTypePool[i].m_InstruID = m_onChipData.m_InstruID THEN
		checkInstruType:=TRUE;
		m_instruTypeInfo := g_instruTypePool[i];
		EXIT;
	END_IF
END_FOR

// return directly if instrument ID is invalid
IF NOT(checkInstruType) THEN
	RETURN;
END_IF
IF m_onChipData.m_InstruID = 31 THEN
	m_instruType := InstruType_Endoscope;
	m_endoscopeRotateReduction := 1.0;
	m_endoscopeRotJntIdx := 7;
ELSE
	m_instruType := m_onChipData.m_InstruID;
	m_endoscopeRotateReduction := 2.0/3.0;
	m_endoscopeRotJntIdx := 8;
END_IF


// update DH joint limit
m_instruTypeInfo.m_rodLength := m_instruTypeInfo.m_rodLength - GVL_SlaveArmKinematic.g_panelHeight;
m_wristMinDHJntPos[1]:=-m_instruTypeInfo.m_rollLimit;
m_wristMaxDHJntPos[1]:=m_instruTypeInfo.m_rollLimit;
m_wristMinDHJntPos[2]:=-m_instruTypeInfo.m_pitchLimit-pi/2;
m_wristMaxDHJntPos[2]:=m_instruTypeInfo.m_pitchLimit-pi/2;
m_wristMinDHJntPos[3]:=-m_instruTypeInfo.m_yawLimit;
m_wristMaxDHJntPos[3]:=m_instruTypeInfo.m_yawLimit;]]></ST>
      </Implementation>
    </Method>
    <Property Name="curScopePosture" Id="{c327ac7d-1ff6-4f6a-8d7d-377863afa9ff}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY curScopePosture : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{3340ac94-9c36-4f32-8601-dac4725b2a6d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[curScopePosture:= m_curEndoscopePosture;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f31b6899-d58a-4db8-8485-bf28ba7830a5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_curEndoscopePosture := curScopePosture;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="curScopeType" Id="{4bce8a98-2eb7-4bb1-9eae-0e7d18b990ab}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY curScopeType : E_EndoscopeType]]></Declaration>
      <Get Name="Get" Id="{abceb35e-0bca-4bf2-b494-bd59bc26f3c4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[curScopeType := m_curEndoscopeType;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b042366b-dcc9-4e34-ab02-a26f6cf69d06}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_curEndoscopeType := curScopeType;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="gripAngleMap" Id="{b8d7e03a-0cbe-42c6-a7e6-6b03109deb8f}">
      <Declaration><![CDATA[METHOD PUBLIC gripAngleMap : BOOL
VAR_INPUT
	// master gripper angle
	i_masterGripAng :LREAL;
END_VAR

VAR_OUTPUT
	// slave instrument gripper angle
	o_instruGripAngle :LREAL;
	
	// slave instrument grip force	
	o_instruGripForceLevel :LREAL;
END_VAR

VAR
	gripLevel :REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// suppose finger is  closed and zero force if instrument has only one finger
IF m_instruTypeInfo.m_isSingleFinger THEN
	o_instruGripAngle := 0;
	o_instruGripForceLevel:= 0;
	RETURN;
END_IF 

// finger closed and force applied
IF i_masterGripAng < g_masterGripForceStartAng THEN
	o_instruGripAngle := g_minSlaveGripAngle;
	// NOTE: force is applied from 50%，as minimum gripper angle already apply some sort of force
	o_instruGripForceLevel := 30+70*(g_masterGripForceStartAng - i_masterGripAng)/(g_masterGripForceStartAng - g_minMasterGripAngle);
// finger open
ELSE
	o_instruGripAngle := (g_maxMasterGripAngle - i_masterGripAng)/(g_maxMasterGripAngle - g_masterGripForceStartAng);
	o_instruGripAngle :=m_instruTypeInfo.m_maxGripAngle - o_instruGripAngle * (m_instruTypeInfo.m_maxGripAngle - g_minSlaveGripAngle);
	o_instruGripAngle := LIMIT(g_minSlaveGripAngle, o_instruGripAngle, m_instruTypeInfo.m_maxGripAngle );
	o_instruGripForceLevel:=0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{b6799ae1-8e52-4442-8aea-44a9f33a3afc}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_INPUT
	armIdx :INT;
END_VAR
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Update the IP and port number of the operating arm
m_armNetId:=GVL_SlaveJointEncoderCaliData.g_slaveArmNetID[armIdx];
m_setupArmNetId := GVL_SetupJointEncoderCaliData.g_setupArmNetID[armIdx];
m_jointInstruAddr:=GVL_SlaveJointEncoderCaliData.g_slaveJointNetPort[armIdx,4];
m_LEDAddr := GVL_SetupJointEncoderCaliData.g_setupLEDNetPort[armIdx];

// init joint motion range
FOR i:=1 TO 3 DO
	m_wristMinDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i+3];
	m_wristMaxDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i+3];
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="initInstruJntPos" Id="{9abce61f-f34d-42ca-a401-a8190ac28e6c}">
      <Declaration><![CDATA[METHOD PUBLIC initInstruJntPos : BOOL
VAR_INPUT
	m_curJntPos :Vec8d;
END_VAR

VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=m_curJntPos[i];
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruFK" Id="{097c05ed-881a-44a5-815d-27300cef479f}">
      <Declaration><![CDATA[// convert motor joint position to DH joint position
METHOD PUBLIC instruFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint position of slave arm
	i_jntPos :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint positon
	r_DHJntPos :Vec6d;

	// gripper angle
	r_gripAngle :LREAL;
END_VAR

VAR
	jntPosL1,jntPosL2,jntPosL3,jntPosL4,jntPosL5 :LREAL;
	gripAngle:LREAL;
	kx,ky,kz, k13, k23,openAngleDir:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntPos[1]:=i_jntPos[1];
r_DHJntPos[2]:=i_jntPos[2];
r_DHJntPos[3]:=i_jntPos[3];

// kinematic variables
openAngleDir:=-1;
kx:=-1;
ky:=m_instruTypeInfo.m_k2;
kz:=m_instruTypeInfo.m_k1;
k13:=m_instruTypeInfo.m_k3;
k23:=m_instruTypeInfo.m_k3;


// ################## endoscope ############################
IF m_instruType = InstruType_endoscope THEN
	r_DHJntPos[4]:=m_endoscopeRotateReduction*(i_jntPos[m_endoscopeRotJntIdx]-m_jntPosOffset[m_endoscopeRotJntIdx]);
	IF m_curEndoscopeType = EndoScopeType_30 THEN
		r_DHJntPos[5]:=-pi/2+30*g_deg2Rad;
	ELSE
		r_DHJntPos[5]:=-pi/2;
	END_IF
	r_DHJntPos[6]:=0;
	RETURN;
END_IF

// ################## ultrosonic knief ############################
IF m_instruType = InstruType_UltrasoundKnifeS OR m_instruType = InstruType_UltrasoundKnifeU THEN
	r_DHJntPos[4]:=-(i_jntPos[8]-m_jntPosOffset[8])/kx;
	r_DHJntPos[5]:=-pi/2;
	r_DHJntPos[6]:=0;
	r_gripAngle:=ultrasoundKnifeGripAngleFK(i_jntPos[6]-m_jntPosOffset[6]);
	RETURN;
END_IF


//#################### instrument forward kinematic ############
// convert motor joint position to instrument joint position
jntPosL1:=(i_jntPos[4]-m_jntPosOffset[4]);
jntPosL2:=(i_jntPos[5]-m_jntPosOffset[5]);
jntPosL3:=(i_jntPos[6]-m_jntPosOffset[6]);
jntPosL4:=-(i_jntPos[7]-m_jntPosOffset[7]);
jntPosL5:=-(i_jntPos[8]-m_jntPosOffset[8]);

// diable L1 if instrument is single finger
IF m_instruTypeInfo.m_isSingleFinger THEN
	jntPosL1 := -jntPosL2;
END_IF

// instrument FK in local coordinate
r_DHJntPos[4]:=jntPosL4/kx;
r_DHJntPos[5]:=jntPosL3/ky;
r_DHJntPos[6]:=(jntPosL1-jntPosL2-2*r_DHJntPos[5]*k13*kz)/(2*openAngleDir*kz);

// convert instrument rotation to arm DH joint position
r_DHJntPos[5]:=-r_DHJntPos[5]-pi/2;
r_DHJntPos[6]:=-r_DHJntPos[6];

// grip angle
gripAngle:=(jntPosL1+jntPosL2)/(openAngleDir*kz);

//################### gripper angle handle #################
IF (InstruType_ProGraspForceps=m_instruType OR InstruType_ForceBipolar=m_instruType) THEN//细齿无创抓钳
	proGrsapForcepsGripAngleFK(frontAngle:= gripAngle, endAngle=> r_gripAngle);

ELSIF (InstruType_CauteryHook = m_instruType OR InstruType_CauterySpatula = m_instruType) THEN//单级电钩
	r_gripAngle:=0;
ELSE
	r_gripAngle:=gripAngle;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruIDRecord" Id="{f3567262-d84c-4741-97fb-36ae0b451ee9}">
      <Declaration><![CDATA[METHOD PROTECTED InstruIDRecord :ARRAY [1..100] OF  ULINT
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
END_VAR

VAR
	k1:INT;
	Have_Data:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		Have_Data:=TRUE;
		EXIT;
	ELSE
		Have_Data:=FALSE;
	END_IF
END_FOR

IF Have_Data=FALSE THEN
	FOR k1:= 1 TO 99 BY 1 DO
		InstruIDRecord[k1+1]:=i_ArrayData[k1];
	END_FOR
	InstruIDRecord[1]:=i_NewValue;
ELSE
	InstruIDRecord:=i_ArrayData ;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruIK" Id="{9a18f93c-de08-4a8c-a2e3-32833c619719}">
      <Declaration><![CDATA[METHOD PUBLIC instruIK : BOOL
VAR_INPUT
	// DH  joint positon
	i_DHJntPos :Vec6d;

	// gripper angle
	i_gripAngle :LREAL;
	
END_VAR
VAR_OUTPUT
	o_jntPos:Vec8d;
END_VAR
VAR
	gripAngle:LREAL;
	i:INT;
	rot_x:lreal;
	rot_y:lreal;
	rot_z:lreal;

	kx,ky,kz,k13,k23:LREAL;
	d,ra:LREAL;
	
	m_gripAnglePbox:Vec8d;

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[o_jntPos[1] := i_DHJntPos[1];
o_jntPos[2] := i_DHJntPos[2];
o_jntPos[3] := i_DHJntPos[3];

// kinematic variables
d:=-1;
kx:=-1;
ky:=m_instruTypeInfo.m_k2;
kz:=m_instruTypeInfo.m_k1;
k13:=m_instruTypeInfo.m_k3;
k23:=m_instruTypeInfo.m_k3;

// ################## endoscope ############################
IF m_instruType = InstruType_endoscope THEN
	o_jntPos[8] := i_DHJntPos[4]/m_endoscopeRotateReduction + m_jntPosOffset[m_endoscopeRotJntIdx];
	o_jntPos[4]:=0;
	o_jntPos[5]:=0;
	o_jntPos[6]:=0;
	o_jntPos[7]:=0;
	RETURN;
END_IF

//################### gripper angle handle #################
IF (InstruType_ProGraspForceps=m_instruType OR InstruType_ForceBipolar=m_instruType) THEN//细齿无创抓钳
	proGrsapForcepsGripAngleIK(endAngle:= i_gripAngle, frontAngle=> gripAngle);
	
ELSIF (InstruType_CauteryHook = m_instruType OR InstruType_CauterySpatula = m_instruType)  THEN//单级电钩\电铲
	gripAngle:=0;
	
ELSE
	gripAngle:=i_gripAngle;
END_IF

// ################# instrument inverse kinematic ##############
// convert arm DH joint position to  instrument rotation
rot_x:=i_DHJntPos[4];
rot_y:=-i_DHJntPos[5]-pi/2;
rot_z:=-i_DHJntPos[6];

// ################## ultrosonic knief ############################
IF InstruType_UltrasoundKnifeS = onChipData.m_InstruID OR InstruType_UltrasoundKnifeU = onChipData.m_InstruID THEN
	m_gripAnglePbox[4]:=0;
	m_gripAnglePbox[5]:=0;
	m_gripAnglePbox[6]:=ultrasoundKnifeGripAngleIK(gripAngle); 
	m_gripAnglePbox[7]:=rot_x*kx;
	m_gripAnglePbox[8]:=rot_x*kx;
ELSE
	m_gripAnglePbox[7]:=rot_x*kx;
	m_gripAnglePbox[6]:=rot_y*ky;
	ra:=gripAngle;
	m_gripAnglePbox[4]:=rot_y*k13*kz+d*rot_z*kz+d*ra*kz/2;
	m_gripAnglePbox[5]:=-rot_y*k23*kz-d*rot_z*kz+d*ra*kz/2;
END_IF

// convert instrument joint position to motor joint position
o_jntPos[4] := m_gripAnglePbox[4] + m_jntPosOffset[4];
o_jntPos[5] := m_gripAnglePbox[5] + m_jntPosOffset[5];
o_jntPos[6] := m_gripAnglePbox[6] + m_jntPosOffset[6];
o_jntPos[7] := -m_gripAnglePbox[7] + m_jntPosOffset[7];
o_jntPos[8] := -m_gripAnglePbox[8] + m_jntPosOffset[8];


]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruJntVelFK" Id="{a9276aa2-9909-457e-91a6-03a2e37295b6}">
      <Declaration><![CDATA[// convert motor joint velocity to DH joint velocity
METHOD PUBLIC instruJntVelFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint velocity of slave arm
	i_jntVel :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint velocity
	r_DHJntVel :Vec6d;
END_VAR

VAR
	kx,ky,kz, k13, k23,openAngleDir:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntVel[1]:=i_jntVel[1];
r_DHJntVel[2]:=i_jntVel[2];
r_DHJntVel[3]:=i_jntVel[3];

// kinematic variables
openAngleDir:=-1;
kx:=-1;
ky:=m_instruTypeInfo.m_k2;
kz:=m_instruTypeInfo.m_k1;
k13:=m_instruTypeInfo.m_k3;
k23:=m_instruTypeInfo.m_k3;

r_DHJntVel[4]:=-i_jntVel[7]/kx;
r_DHJntVel[5]:=i_jntVel[6]/ky;
r_DHJntVel[6]:=(i_jntVel[4]-i_jntVel[5]-2*r_DHJntVel[5]*k13*kz)/(2*openAngleDir*kz);
r_DHJntVel[5]:=-r_DHJntVel[5];
r_DHJntVel[6]:=-r_DHJntVel[6];]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruSreiesFind" Id="{f880300d-e9dd-456f-88b6-72b1cc8bd3d5}">
      <Declaration><![CDATA[METHOD PROTECTED InstruSreiesFind : BOOL
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
	
END_VAR

VAR
	k1:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[InstruSreiesFind:=FALSE;
FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		InstruSreiesFind:=TRUE;
		EXIT;
	ELSE
		InstruSreiesFind:=FALSE;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Property Name="instruType" Id="{dee9b466-61c8-4830-8c3c-8317ba8d7fb1}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY PUBLIC instruType : E_InstrumentType]]></Declaration>
      <Get Name="Get" Id="{49e23c7c-bb55-4631-aecb-7cce8ba4d643}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruType := m_instruType;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="instruTypeInfo" Id="{b9fcaa60-b5cd-4a50-8265-2d17db413785}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY instruTypeInfo :REFERENCE TO ST_InstruTypeInfo]]></Declaration>
      <Get Name="Get" Id="{968c9c62-53c5-44c8-9697-e18b0987cacf}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruTypeInfo REF= m_instruTypeInfo;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="nextScopePosture" Id="{48ece37f-c5c3-453e-afe5-8c33fe7eb315}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY nextScopePosture : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{07de26d8-dacc-432f-85c8-f04024d47afd}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nextScopePosture:= m_nextEndoscopePosture;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{33462dd0-4b03-403d-a99e-110b0590fa7e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_nextEndoscopePosture := nextScopePosture;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="nextScopeType" Id="{dca96b48-db31-4f08-81c0-25e9bd0712eb}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY nextScopeType : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{815f56b6-cf18-45a1-a9a3-a7d0c73baa6e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nextScopeType:= m_nextEndoscopeType;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{a373dd0f-9a3d-404d-a5d3-2cea57ae861a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_nextEndoscopeType := nextScopeType;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="onChipData" Id="{093a4217-bb32-41a8-a667-4570e97851b1}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY onChipData : REFERENCE TO ST_InstruOnChipData]]></Declaration>
      <Get Name="Get" Id="{f9328823-d656-4b2e-b51e-d2d3d6c6297d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[onChipData ref=m_onChipData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="proGrsapForcepsGripAngleFK" Id="{d3dda96d-7b55-4cf3-9ffe-c8cf53ace77d}">
      <Declaration><![CDATA[METHOD PROTECTED proGrsapForcepsGripAngleFK : BOOL
VAR_INPUT
	frontAngle:LREAL;
END_VAR
VAR_OUTPUT
	endAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	// prograsp data
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	initA:LREAL := 16.6 * g_deg2Rad; 
	initC:LREAL := 8.75*g_deg2Rad;
	
	SIN_C,Angle_Inc_C,Angle_C,Angle_A,Angle_Inc_A:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//**************已知：器械前端开合角，求解：末端开合角***************//
// determine prograsp type data
IF InstruType_ProGraspForceps=m_instruType THEN
	AB:=g_proGraspAB;
	BC:=g_proGraspBC;
	initA := g_proGraspInitA;
	initC := g_proGraspInitC;
ELSIF InstruType_ForceBipolar=m_instruType THEN
	AB:=g_proGrasp2AB;
	BC:=g_proGrasp2BC;
	initA := g_proGrasp2InitA;
	initC := g_proGrasp2InitC;
END_IF

Angle_Inc_A:=frontAngle/2;
Angle_A:=initA+Angle_Inc_A;
Angle_A := LIMIT(0.0, Angle_A, pi);

SIN_C:=AB*SIN(Angle_A)/BC;
Angle_C:=ASIN(SIN_C);

Angle_Inc_C:=Angle_C-initC;
endAngle:=Angle_Inc_C*2;]]></ST>
      </Implementation>
    </Method>
    <Method Name="proGrsapForcepsGripAngleIK" Id="{d41bf91a-0d5c-464e-b520-ee71cb3a1637}">
      <Declaration><![CDATA[METHOD PROTECTED proGrsapForcepsGripAngleIK : BOOL
VAR_INPUT
	endAngle:LREAL;
END_VAR
VAR_OUTPUT
	frontAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	initA:LREAL := 16.6 * g_deg2Rad; 
	initC:LREAL := 8.75*g_deg2Rad;
	Angle_Inc_C,Angle_C,SIN_A,Angle_A,Angle_Inc_A:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//***************已知：器械末端开合角，求解：前端开合角********************//
// determine prograsp type data
IF InstruType_ProGraspForceps=m_instruType THEN
	AB:=g_proGraspAB;
	BC:=g_proGraspBC;
	initA := g_proGraspInitA;
	initC := g_proGraspInitC;
ELSIF InstruType_ForceBipolar=m_instruType THEN
	AB:=g_proGrasp2AB;
	BC:=g_proGrasp2BC;
	initA := g_proGrasp2InitA;
	initC := g_proGrasp2InitC;
END_IF

Angle_Inc_C:=endAngle/2;
Angle_C:=initC+Angle_Inc_C;
Angle_C := LIMIT(0, Angle_C, pi);

SIN_A:=BC*SIN(Angle_C)/AB;
Angle_A:=ASIN(SIN_A);

Angle_Inc_A:=Angle_A-initA;
frontAngle:=Angle_Inc_A*2;]]></ST>
      </Implementation>
    </Method>
    <Method Name="readParameters" Id="{fafb5a79-7caf-47d4-9d2f-b3dbd95048cf}">
      <Declaration><![CDATA[METHOD PUBLIC readParameters : BOOL
VAR_INPUT
	startFlag :BOOL;
END_VAR

VAR
	paramIdx :INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: read m_kinematic parameters from chip 
//Take the rising edge of the read signal
m_ReadDelay(IN:= m_Step=10, PT:= m_DealyTime, Q=> , ET=> );//计时器
IF startFlag AND m_curReadTries < m_maxReadTries THEN
	m_Step:=0;
	m_onChipData.m_InstruReadSucceed:=FALSE;
	m_onChipData.m_Error:=FALSE;
	m_onChipData.m_ErrorID:=0;
	m_resetArmLEDFlag :=TRUE;
END_IF


CASE m_Step OF
	
	0://向6093发送0x8000  0000---发送读取信号
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6093, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=10;
		END_IF
		
		
	10://延时0.5s、防止值还没有返回
		IF m_ReadDelay.Q THEN
			m_Step:=20;
		END_IF

		
	20://从6093地址中拿值
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6093, pDstBuf:= ADR(m_IDReadResult), cbBufLen:= SIZEOF(m_IDReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=30;
		END_IF	
		
	
	30://处理器械ID、低16位
		m_IDResult:=UDINT_TO_ULINT(16#0000FFFF AND m_IDReadResult);
		m_Step:=40;
		
		
	40://读取6095、器械序列号
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6095, pDstBuf:= ADR(m_SeriesReadResult), cbBufLen:= SIZEOF(m_SeriesReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=50;
		END_IF	
	
		
	50://处理序列号，低30位
		m_onChipData.m_InstruseriesNum:=SHL(m_IDResult,31)+(16#7FFFFFFF AND m_SeriesReadResult);
		m_onChipData.m_InstruID:=LREAL_TO_INT(FLOOR(lr_in:= m_onChipData.m_InstruseriesNum/EXPT(10,9))); //取十进制前三位为器械ID
		m_Step:=60;
		
		
	60://读取6096---器械零点位置
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6096, pDstBuf:= ADR(m_PosReadResult), cbBufLen:= SIZEOF(m_PosReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=70;
		END_IF	
		
		
	70: //处理位置，L1:0-9位，L2:10-19位，L3:20-29位
		zeroPosDecode(m_PosReadResult, o_q1=>m_onChipData.m_InstruPos[1],o_q2=>m_onChipData.m_InstruPos[2],o_q3=>m_onChipData.m_InstruPos[3]);
		m_onChipData.m_InstruPos[4] := m_jnt4ZeroPos;
		m_onChipData.m_InstruPos[5] := 0;
		
		m_Step:=80;
		
	80://读取器械使用次数 6094
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_UsageReadResult), cbBufLen:= SIZEOF(m_UsageReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=90;
		END_IF	
		
		
	90://处理器械使用次数读取结果
		m_onChipData.m_InstruusageCounts:=m_UsageReadResult;
		m_InstruUsageToLED:=LIMIT(0,m_UsageReadResult,99);
		m_Step:=100;
		
		
	100://将器械使用次数写入LED
		m_Value:=ULINT_TO_UDINT(16#FFFF AND m_InstruUsageToLED) ;
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_LEDAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=110;
		END_IF
		
	110:
		// get insturment typeinfo
		m_onChipData.m_InstruReadSucceed:=checkInstruType();
		//结果诊断
		m_onChipData.m_ErrorID:=0;
		IF NOT(m_onChipData.m_InstruReadSucceed) THEN
			m_onChipData.m_Error:=TRUE;
			m_onChipData.m_ErrorID:=1;
			
		ELSIF SlaveArmControl.m_slaveRobot.m_endoscopeMounted AND m_instruType = InstruType_Endoscope THEN
			m_onChipData.m_InstruReadSucceed := FALSE;
			m_onChipData.m_Error:=TRUE;
			m_onChipData.m_ErrorID:=3;
			
		ELSIF m_onChipData.m_InstruusageCounts>(m_instruTypeInfo.m_maxUseNum -1+100) AND m_instruType<>InstruType_Endoscope THEN
			m_HaveRecord:=InstruSreiesFind(i_NewValue:=m_onChipData.m_InstruseriesNum , i_ArrayData:=GVL_interactUI.g_InstruSeriesRecord );
			IF m_HaveRecord THEN
				//
			ELSE
				m_onChipData.m_InstruReadSucceed := FALSE; 
				m_onChipData.m_Error:=TRUE;
				m_onChipData.m_ErrorID:=2;
			END_IF
		END_IF
		
		//处理当器械使用次数达到上限后、在同一场手术中还能使用
		IF m_onChipData.m_InstruReadSucceed AND m_onChipData.m_InstruusageCounts=(m_instruTypeInfo.m_maxUseNum -1) THEN		
			//TODO: check this part
			GVL_interactUI.g_InstruSeriesRecord:=InstruIDRecord(i_NewValue:= m_onChipData.m_InstruseriesNum, i_ArrayData:= GVL_interactUI.g_InstruSeriesRecord);
		END_IF
		
		m_Step :=-1;
		m_curReadTries := m_curReadTries +1;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{90292eaa-1cc4-4b19-b4f6-6bcd7c03eb33}">
      <Declaration><![CDATA[METHOD PUBLIC reset : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_Step := -1;
m_curReadTries := 0;
m_onChipData.m_InstruID := 0;
m_onChipData.m_InstruseriesNum :=0;
m_onChipData.m_Error:=FALSE;
m_onChipData.m_ErrorID:=0;
m_onChipData.m_InstruReadSucceed:=FALSE;
m_instruType:=InstruType_UNKNOWM;

FOR i:= 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=0;
END_FOR

// init joint motion range
FOR i:=1 TO 3 DO
	m_wristMinDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i+3];
	m_wristMaxDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i+3];
END_FOR

// reset endoscope type and posture
m_curEndoscopeType :=EndoScopeType_30;
m_nextEndoscopeType :=EndoScopeType_30;
m_curEndoscopePosture :=EndoscopePosture_HeadDown;
m_nextEndoscopePosture :=EndoscopePosture_HeadDown;

//arm LED reset
IF m_resetArmLEDFlag THEN
	m_Value:=0 ;
	m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_LEDAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
END_IF
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	m_resetArmLEDFlag := FALSE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="resetArmLED" Id="{71d71091-a005-44ba-bc61-7d4e51a8100a}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY resetArmLED : BOOL]]></Declaration>
      <Set Name="Set" Id="{0e15a6e1-bfbd-4e2e-955b-940522cefd73}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_resetArmLEDFlag := resetArmLED;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="ultrasoundKnifeGripAngleFK" Id="{1dc50a9a-b451-47d4-9f26-74d3cb81d7ff}">
      <Declaration><![CDATA[METHOD ultrasoundKnifeGripAngleFK : LREAL
VAR_INPUT
	// motor joint position of slave arm
	i_jntPos :LREAL;
END_VAR

VAR
	m_jntPos : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_jntPos := i_jntPos;

m_jntPos := LIMIT (-20*g_deg2Rad,m_jntPos,70*g_deg2Rad);

ultrasoundKnifeGripAngleFK := ASIN((m_jntPos*g_uknifeMotorLead * g_uknifeLeverRatio/(2*pi) -  g_uknifeGripTravel * SIN(g_uknifeGripDividAngle))/g_uknifeGripTravel)+g_uknifeGripDividAngle;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ultrasoundKnifeGripAngleIK" Id="{540a0ddb-6d91-4142-b9a4-ee974de5f7d5}">
      <Declaration><![CDATA[METHOD ultrasoundKnifeGripAngleIK : LREAL
VAR_INPUT
	// gripper angle
	i_gripAngle :LREAL;
END_VAR

VAR
	m_gripAngle : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_gripAngle := i_gripAngle;

ultrasoundKnifeGripAngleIK := (g_uknifeGripTravel * (SIN(g_uknifeGripDividAngle) - SIN(g_uknifeGripDividAngle - m_gripAngle))/(g_uknifeMotorLead*g_uknifeLeverRatio/(2*pi)));]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeNumOfUseToChip" Id="{c72f85d3-5b0f-42d8-878f-c490a6c1ecdf}">
      <Declaration><![CDATA[METHOD writeNumOfUseToChip : BOOL
VAR_INPUT
	startFlag :BOOL;
	i_useNumFromUI :UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[writeNumOfUseToChip := FALSE;
m_writeLDP(CLK:= startFlag, Q=> );
m_ReadNumDelay(IN:= m_useNumStep = 10, PT:= m_DealyTime, Q=> , ET=> );
IF m_writeLDP.Q THEN
	m_useNumStep:=0;
END_IF

CASE m_useNumStep OF
	0: 
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6094, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_useNumStep:=10;
		END_IF
	
	10:
		IF m_ReadNumDelay.Q THEN
			m_useNumStep:=20;
		END_IF
		
	20:
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_useNumReadResult), cbBufLen:= SIZEOF(m_useNumReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_useNumStep:=30;
		END_IF
		
	30://Verify the actual usage count and the usage count given by the UI
		IF m_useNumReadResult = i_useNumFromUI THEN
			m_useNumSendToLED := LIMIT(0, m_useNumReadResult, 99);
			m_useNumStep:=40;
		ELSE
			m_useNumStep:=50;
		END_IF
		
	40: 
		m_Value:=ULINT_TO_UDINT( m_useNumSendToLED) ;
		m_SdoWrite(sNetId:= m_setupArmNetId, nSlaveAddr:= m_LEDAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_onChipData.m_InstruUsageCounts:=m_useNumReadResult;
			writeNumOfUseToChip := TRUE;
			m_useNumStep:=-1;
		END_IF
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeZeroPosToChip" Id="{bd19b6c1-405e-4351-971f-f03bf3bea173}">
      <Declaration><![CDATA[METHOD PUBLIC writeZeroPosToChip : BOOL
VAR_INPUT
	i_q1:LREAL;
	i_q2:LREAL;
	i_q3:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[zeroPosCode(i_q1,i_q2,i_q3, o_code=>m_zeroPosCode);

writeZeroPosToChip:=FALSE;
m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6096, pSrcBuf:= ADR(m_zeroPosCode), cbBufLen:= SIZEOF(m_zeroPosCode), bExecute:= TRUE, );
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	writeZeroPosToChip:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="zeroPosCode" Id="{84c93418-be66-4d42-a7c9-9496164ac08f}">
      <Declaration><![CDATA[// code instrument joints(4/5/6) zero position as a UDINT
// joint1 : bit 21-30; joint2: bit 11-20; joint3: bit1-10
// zeroPos: [0, 2pi]; code:[0-3sFF]
METHOD PROTECTED zeroPosCode : BOOL
VAR_INPUT
	i_q1:LREAL;
	i_q2:LREAL;
	i_q3:LREAL;
END_VAR
VAR_OUTPUT
	o_code:UDINT;
END_VAR
VAR
	posCode:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// highest bit set to 1
o_code:=2;

// joint1
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q1/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;

// joint2
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q2/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;

// joint3
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q3/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="zeroPosDecode" Id="{7d5604d0-0288-46b2-b433-10a7497ca58f}">
      <Declaration><![CDATA[// decode instrument joints(4/5/6) zero position from a UDINT
// joint1 : bit 21-30; joint2: bit 11-20; joint4: bit1-10
// zeroPos: [0, 2pi]; code:[0-2FF]
METHOD PROTECTED zeroPosDecode : BOOL
VAR_INPUT
	i_posCode :UDINT;
END_VAR
VAR_OUTPUT
	o_q1:LREAL;
	o_q2:LREAL;
	o_q3:LREAL;
END_VAR
VAR
	posCode:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// joint3
posCode := i_posCode AND 16#3FF;
o_q3 := g_2pi *  posCode/16#3FF;

// joint2
i_posCode := SHR(i_posCode, 10);
posCode := i_posCode AND 16#3FF;
o_q2 := g_2pi *  posCode/16#3FF;

// joint1
i_posCode := SHR(i_posCode, 10);
posCode := i_posCode AND 16#3FF;
o_q1 := g_2pi *  posCode/16#3FF;
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Instrument">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.checkInstruType">
      <LineId Id="439" Count="15" />
      <LineId Id="475" Count="0" />
      <LineId Id="493" Count="0" />
      <LineId Id="455" Count="1" />
      <LineId Id="479" Count="0" />
      <LineId Id="494" Count="0" />
      <LineId Id="457" Count="3" />
      <LineId Id="486" Count="0" />
      <LineId Id="461" Count="5" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopePosture.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopePosture.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopeType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopeType.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.gripAngleMap">
      <LineId Id="137" Count="17" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.init">
      <LineId Id="47" Count="1" />
      <LineId Id="64" Count="0" />
      <LineId Id="49" Count="7" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.initInstruJntPos">
      <LineId Id="20" Count="1" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruFK">
      <LineId Id="525" Count="69" />
      <LineId Id="159" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruIDRecord">
      <LineId Id="38" Count="15" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruIK">
      <LineId Id="705" Count="61" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruJntVelFK">
      <LineId Id="252" Count="15" />
      <LineId Id="220" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruSreiesFind">
      <LineId Id="34" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruTypeInfo.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopePosture.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopePosture.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopeType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopeType.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.onChipData.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.proGrsapForcepsGripAngleFK">
      <LineId Id="78" Count="21" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.proGrsapForcepsGripAngleIK">
      <LineId Id="85" Count="21" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.readParameters">
      <LineId Id="1115" Count="95" />
      <LineId Id="1212" Count="30" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.reset">
      <LineId Id="226" Count="34" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.resetArmLED.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.ultrasoundKnifeGripAngleFK">
      <LineId Id="16" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.ultrasoundKnifeGripAngleIK">
      <LineId Id="14" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeNumOfUseToChip">
      <LineId Id="74" Count="45" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeZeroPosToChip">
      <LineId Id="16" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="17" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.zeroPosCode">
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="45" Count="2" />
      <LineId Id="58" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="50" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="55" Count="2" />
      <LineId Id="54" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.zeroPosDecode">
      <LineId Id="40" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="68" Count="3" />
      <LineId Id="67" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>